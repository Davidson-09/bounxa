"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForReceivingTransaction = waitForReceivingTransaction;
const api_js_1 = require("../services/api.js");
const errors_js_1 = require("../errors/errors.js");
const utils_js_1 = require("../utils/utils.js");
const processMessages_js_1 = require("./processMessages.js");
const TRANSACTION_HASH_OBSERVERS = {};
async function waitForReceivingTransaction(txHash, statusManager, processType, step) {
    const _getStatus = () => new Promise(async (resolve, reject) => {
        let statusResponse;
        try {
            statusResponse = await (0, api_js_1.getStatus)({
                fromChain: step.action.fromChainId,
                toChain: step.action.toChainId,
                txHash,
                ...(step.tool !== 'custom' && { bridge: step.tool }),
            });
        }
        catch (e) {
            console.debug('Fetching status from backend failed.', e);
            return resolve(undefined);
        }
        switch (statusResponse.status) {
            case 'DONE':
                return resolve(statusResponse);
            case 'PENDING':
                statusManager?.updateProcess(step, processType, 'PENDING', {
                    substatus: statusResponse.substatus,
                    substatusMessage: statusResponse.substatusMessage ||
                        (0, processMessages_js_1.getSubstatusMessage)(statusResponse.status, statusResponse.substatus),
                    txLink: statusResponse.bridgeExplorerLink,
                });
                return resolve(undefined);
            case 'NOT_FOUND':
                return resolve(undefined);
            case 'INVALID':
            case 'FAILED':
            default:
                return reject();
        }
    });
    let status;
    if (txHash in TRANSACTION_HASH_OBSERVERS) {
        status = await TRANSACTION_HASH_OBSERVERS[txHash];
    }
    else {
        TRANSACTION_HASH_OBSERVERS[txHash] = (0, utils_js_1.repeatUntilDone)(_getStatus, 5_000);
        status = await TRANSACTION_HASH_OBSERVERS[txHash];
    }
    if (!('receiving' in status)) {
        throw new errors_js_1.ServerError("Status doesn't contain receiving information.");
    }
    return status;
}
//# sourceMappingURL=waitForReceivingTransaction.js.map