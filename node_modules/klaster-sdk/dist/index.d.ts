import { Hex } from "viem";
import { TxFeeParams, ExecuteResponse, InterchainTransaction, QuoteResponse } from "./types";
import { AccountInitData, MultichainAccount } from "./accounts/account.service";
import { PaymentTokenSymbol } from "./utils/token-utils/token-resolver.service";
export * from "./types";
export * from "./utils/encoding.service";
export * from "./utils/itx.service";
export * from "./utils/salt.service";
export * from "./utils/token-utils/token-resolver.service";
export * from "./utils/token-utils/token-utilization-strategy.service";
export * from "./utils/token-utils/erc20-encoder.service";
export * from "./utils/constants/node-url.constants";
export * from "./utils/chains.service";
export * from "./utils/token-mapping.service";
export * from "./utils/constants/common-tokens.constants";
export * from './accounts/account.service';
export * from './accounts/account-vendors/biconomy.account';
export * from './accounts/account-vendors/safe.account';
export { Address } from "viem";
export type Config<T> = {
    nodeUrl: string;
    accountInitData: T;
};
export declare function initKlaster<T extends AccountInitData<Object>>(config: Config<T>): Promise<KlasterSDK<T>>;
export declare class KlasterSDK<T extends AccountInitData<Object>> {
    private nodeService;
    activeAccountSalt: string;
    private accountInitData;
    account: MultichainAccount;
    private constructor();
    static init<T extends AccountInitData<Object>>(config: Config<T>): Promise<KlasterSDK<T>>;
    private initMultichainAccount;
    getQuote(itx: InterchainTransaction): Promise<QuoteResponse>;
    encodePaymentFee(chainId: number, token: PaymentTokenSymbol): TxFeeParams;
    execute(response: QuoteResponse, signedHash: string): Promise<ExecuteResponse>;
    autoExecute(itx: InterchainTransaction, signHash: (hash: Hex) => Promise<string>): Promise<ExecuteResponse>;
}
//# sourceMappingURL=index.d.ts.map